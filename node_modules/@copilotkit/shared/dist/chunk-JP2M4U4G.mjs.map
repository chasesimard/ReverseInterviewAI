{"version":3,"sources":["../src/utils/json-schema.ts"],"sourcesContent":["import { z } from \"zod\";\nimport { Parameter } from \"../types\";\n\nexport type JSONSchemaString = {\n  type: \"string\";\n  description?: string;\n  enum?: string[];\n};\n\nexport type JSONSchemaNumber = {\n  type: \"number\";\n  description?: string;\n};\n\nexport type JSONSchemaBoolean = {\n  type: \"boolean\";\n  description?: string;\n};\n\nexport type JSONSchemaObject = {\n  type: \"object\";\n  properties?: Record<string, JSONSchema>;\n  required?: string[];\n  description?: string;\n};\n\nexport type JSONSchemaArray = {\n  type: \"array\";\n  items: JSONSchema;\n  description?: string;\n};\n\nexport type JSONSchema =\n  | JSONSchemaString\n  | JSONSchemaNumber\n  | JSONSchemaBoolean\n  | JSONSchemaObject\n  | JSONSchemaArray;\n\nexport function actionParametersToJsonSchema(actionParameters: Parameter[]): JSONSchema {\n  // Create the parameters object based on the argumentAnnotations\n  let parameters: { [key: string]: any } = {};\n  for (let parameter of actionParameters || []) {\n    parameters[parameter.name] = convertAttribute(parameter);\n  }\n\n  let requiredParameterNames: string[] = [];\n  for (let arg of actionParameters || []) {\n    if (arg.required !== false) {\n      requiredParameterNames.push(arg.name);\n    }\n  }\n\n  // Create the ChatCompletionFunctions object\n  return {\n    type: \"object\",\n    properties: parameters,\n    required: requiredParameterNames,\n  };\n}\n\nfunction convertAttribute(attribute: Parameter): JSONSchema {\n  switch (attribute.type) {\n    case \"string\":\n      return {\n        type: \"string\",\n        description: attribute.description,\n        ...(attribute.enum && { enum: attribute.enum }),\n      };\n    case \"number\":\n    case \"boolean\":\n      return {\n        type: attribute.type,\n        description: attribute.description,\n      };\n    case \"object\":\n    case \"object[]\":\n      const properties = attribute.attributes?.reduce(\n        (acc, attr) => {\n          acc[attr.name] = convertAttribute(attr);\n          return acc;\n        },\n        {} as Record<string, any>,\n      );\n      const required = attribute.attributes\n        ?.filter((attr) => attr.required !== false)\n        .map((attr) => attr.name);\n      if (attribute.type === \"object[]\") {\n        return {\n          type: \"array\",\n          items: {\n            type: \"object\",\n            ...(properties && { properties }),\n            ...(required && required.length > 0 && { required }),\n          },\n          description: attribute.description,\n        };\n      }\n      return {\n        type: \"object\",\n        description: attribute.description,\n        ...(properties && { properties }),\n        ...(required && required.length > 0 && { required }),\n      };\n    default:\n      // Handle arrays of primitive types and undefined attribute.type\n      if (attribute.type?.endsWith(\"[]\")) {\n        const itemType = attribute.type.slice(0, -2);\n        return {\n          type: \"array\",\n          items: { type: itemType as any },\n          description: attribute.description,\n        };\n      }\n      // Fallback for undefined type or any other unexpected type\n      return {\n        type: \"string\",\n        description: attribute.description,\n      };\n  }\n}\n\nexport function convertJsonSchemaToZodSchema(jsonSchema: any, required: boolean): z.ZodSchema {\n  if (jsonSchema.type === \"object\") {\n    const spec: { [key: string]: z.ZodSchema } = {};\n\n    if (!jsonSchema.properties || !Object.keys(jsonSchema.properties).length) {\n      return !required ? z.object(spec).optional() : z.object(spec);\n    }\n\n    for (const [key, value] of Object.entries(jsonSchema.properties)) {\n      spec[key] = convertJsonSchemaToZodSchema(\n        value,\n        jsonSchema.required ? jsonSchema.required.includes(key) : false,\n      );\n    }\n    let schema = z.object(spec).describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  } else if (jsonSchema.type === \"string\") {\n    let schema = z.string().describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  } else if (jsonSchema.type === \"number\") {\n    let schema = z.number().describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  } else if (jsonSchema.type === \"boolean\") {\n    let schema = z.boolean().describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  } else if (jsonSchema.type === \"array\") {\n    let itemSchema = convertJsonSchemaToZodSchema(jsonSchema.items, true);\n    let schema = z.array(itemSchema).describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  }\n  throw new Error(\"Invalid JSON schema\");\n}\n"],"mappings":"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","names":[]}